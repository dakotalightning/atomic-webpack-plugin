const path = require('path');
const fs = require('fs');

const defaultOptions = {
  base: './src/components',
  output: 'index.ts',
  header: '// @generated\n// This file is automatically generated and should not be edited.\n\n',
  regularExpression: /\.?\/.+\/index\.tsx$/
}

class Atomic {
  constructor(options) {
    this.keys = []
    this.changed = false
    this.files = {}

    this.setOptions(options);

    this.logger = {
      info: console.log,
      error: console.error,
      trace: console.error,
    }
  }

  setOptions(options) {
    const settings = Object.assign({}, this.settings || defaultOptions, options)

    this.base = settings.base
    this.output = settings.output
    this.header = settings.header
    this.logger = settings.logger
    this.scanSubDirectories = settings.scanSubDirectories
    this.regularExpression = settings.regularExpression

    this.settings = settings
  }

  getComponents(directory, scanSubDirectories, regularExpression) {
    this.logger.info('Get Components...', directory)
    this.files = {}
    this.readDirectory(directory, scanSubDirectories, regularExpression);
    this.keys = Object.keys(this.files);
    return this.keys
  }

  readDirectory(directory, scanSubDirectories, regularExpression) {
    fs.readdirSync(directory).forEach((file) => {
      const fullPath = path.resolve(directory, file);

      if (fs.statSync(fullPath).isDirectory()) {
        if (scanSubDirectories) this.readDirectory(fullPath, scanSubDirectories, regularExpression);

        return;
      }

      if (!regularExpression.test(fullPath)) return;

      this.files[fullPath] = true;
    });
  }

  cleanKeys(keys) {
    return keys.map((key) => ({
      key,
      componentName: key.replace(/^.+\.?\/([^/]+)\/index\.tsx/, '$1'),
      from: key.replace(/^.+\.?\/([^\/]+\/[^\/]+)\/index\.tsx/, './$1')
    }))
  }

  check(callback) {
    this.logger.info('Running Check')
    const keys = this.cleanKeys(this.keys)
    let changes = false
    keys.forEach((k) => {
      try {
        fs.accessSync(k.key, fs.F_OK)
        this.logger.debug('\u2713', k.from)
      } catch (err) {
        changes = true
        this.logger.info('Detected component change', k.from)
      }
    });
    if (changes) {
      this.logger.info('Changes detected...')
    } else {
      this.logger.info('No changes...')
    }
    callback.call(this, changes, this.keys, this)
  }

  run(callback) {
    this.logger.info('Run...')

    const resolvedBase = path.resolve(__dirname, this.base)
    const resolvedOutput = path.resolve(__dirname, this.base, this.output)

    try {
      fs.accessSync(resolvedBase, fs.F_OK)
    } catch (err) {
      this.logger.error(`Unable to find ${resolvedBase} check your settings base`)
      return this.logger.trace(err)
    }

    try {
      fs.accessSync(resolvedOutput, fs.F_OK)
    } catch (err) {
      this.logger.error(`Unable to find ${resolvedOutput} check your [output] and [base] options`)
      return this.logger.trace(err)
    }

    const keys = this.getComponents(resolvedBase, this.scanSubDirectories, this.regularExpression)
    const cleanKeys = this.cleanKeys(keys)

    const contentArray = cleanKeys.map((k) => `export { default as ${k.componentName} } from '${k.from}'\n`)
    const content = `${this.header}${contentArray.join('')}`

    try {
      fs.writeFileSync(resolvedOutput, content)
      this.logger.info(`Generated @atomic! ${keys.length} files add to ${resolvedOutput}`)
    } catch (err) {
      this.logger.error('Error writing \'index.ts\'', err)
      return this.logger.trace(err)
    }

    callback.call(this, this.keys, this)
  }
}

class AtomicWebpackPlugin {
  constructor(options) {
    this.keys = []
    this.changed = false
    this.atomic = new Atomic(Object.assign({}, defaultOptions, options || {}))
  }

  apply(compiler) {
    const PLUGIN_NAME = AtomicWebpackPlugin.name;
    const logger = compiler.getInfrastructureLogger('atomic');

    compiler.hooks.environment.tap(PLUGIN_NAME, () => {
      this.atomic.setOptions({
        logger,
      })

      // create the first set
      logger.info('Atomic start');
      this.atomic.run((keys, instance) => {
        logger.info('Done');
      })
    })

    compiler.hooks.run.tapAsync(PLUGIN_NAME, (compiler, callback) => {
      this.atomic.check((changes, keys, instance) => {
        if (changes) {
          this.atomic.run((keys, instance) => {
            logger.info('Done');
          })
        }
        callback();
      })
    });

    compiler.hooks.watchRun.tapAsync(PLUGIN_NAME, (compiler, callback) => {
      this.atomic.check((changes, keys, instance) => {
        if (changes) {
          this.atomic.run((keys, instance) => {
            logger.info('Done');
          })
        }
        callback();
      })
    });
  }
}

module.exports = AtomicWebpackPlugin;
